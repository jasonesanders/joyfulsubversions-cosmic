---
---

<div class="noisy-gradient-container">
  <div class="gradient-bg"></div>
  <svg viewBox="0 0 200 200" xmlns='http://www.w3.org/2000/svg'>
    <filter id='noiseFilter'>
      <feTurbulence 
        type='fractalNoise' 
        baseFrequency='0.65' 
        numOctaves='3' 
        stitchTiles='stitch' />
    </filter>
    <rect width='100%' height='100%' filter='url(#noiseFilter)' />
  </svg>
</div>

<style>
  .noisy-gradient-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -2; /* Behind everything, including the Orb (z-index: 0) */
    pointer-events: none;
    overflow: hidden;
    background-color: #333333; /* Fallback/Start color */
  }

  .gradient-bg {
    position: absolute;
    inset: 0;
    background: radial-gradient(circle at 50% 50%, var(--bg-primary, #333333), var(--bg-secondary, #1a1a1a));
    transition: background 0.5s ease; /* Smooth transition if JS fails */
  }

  svg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 0.15;
    mix-blend-mode: overlay;
    pointer-events: none;
  }
</style>

<script>
  import { gsap } from 'gsap';
  import { ScrollTrigger } from 'gsap/ScrollTrigger';

  gsap.registerPlugin(ScrollTrigger);

  // Define the color palette sequence
  // Start: #333333
  // Transition: #643173 -> #7d5ba6 -> #86a59c -> #89ce94
  const colors = [
    { primary: '#333333', secondary: '#1a1a1a' }, // Hero
    { primary: '#643173', secondary: '#3a1c42' }, // Manifesto
    { primary: '#7d5ba6', secondary: '#4a3661' }, // About
    { primary: '#86a59c', secondary: '#4f615c' }, // Gallery
    { primary: '#89ce94', secondary: '#4d7353' }  // Footer
  ];

  const sections = document.querySelectorAll('section');
  const gradientBg = document.querySelector('.gradient-bg') as HTMLElement;

  if (gradientBg) {
    // Create a timeline that scrubs through the colors based on total scroll
    const tl = gsap.timeline({
      scrollTrigger: {
        trigger: "body",
        start: "top top",
        end: "bottom bottom",
        scrub: 0.5, // Slight smoothing
      }
    });

    // Interpolate colors across the entire scroll distance
    // We use CSS variables to allow the radial gradient to update
    // Note: animating CSS variables with GSAP works well
    
    // Initial state
    gsap.set(gradientBg, {
        '--bg-primary': colors[0].primary,
        '--bg-secondary': colors[0].secondary
    });

    // Animate through the colors
    colors.forEach((color, index) => {
        if (index === 0) return; // Skip start color
        
        // Calculate relative position in timeline
        const position = index / (colors.length - 1);
        
        tl.to(gradientBg, {
            '--bg-primary': color.primary,
            '--bg-secondary': color.secondary,
            ease: "none", // Linear interpolation for scrub
            duration: 1 / (colors.length - 1) // Equal duration for each segment
        }, (index - 1) / (colors.length - 1)); // Start time
    });
  }
</script>
